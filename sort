#pragma once
#include <stdio.h>
#include <stdlib.h>

void swap(int array[], int a, int b)
{
	int temp = array[a];
	array[a] = array[b];
	array[b] = temp;
}

//1.快速排序(递归)
int partition_1(int array[], int left, int right)
{
	//挖坑
	int begin = left;
	int end = right;
	int pivot = array[right];
	while (begin < end)
	{
		while (begin < end && array[begin] < pivot)
		{
			begin++;
		}
		array[end] = array[begin];
		while (begin < end && array[end] > pivot)
		{
			end--;
		}
		array[begin] = array[end];
	}
	array[begin] = pivot;

	return begin;
}
int partition_2(int array[], int left, int right)
{
	int d = left;
	for (int i = left; i < right; ++i)
	{
		if (array[i] < array[right])
		{
			swap(array, i, d);
			d++;
		}
	}
	swap(array, d, right);
	return d;
}
void QuickSortInner(int array[], int left, int right)
{
	if (left == right)
	{
		//size = 1
		return;
	}
	if (left > right)
	{
		//size == 0
		return;
	}
	//确定基准值,目前定为右边
	int d = partition_2(array, left, right);
	//分治,对左右两个区间继续排序
	QuickSortInner(array, left, d - 1);
	QuickSortInner(array, d + 1, right);
}
void QuickSort(int array[], int left, int right)
{
	QuickSortInner(array, left, right);
}

//2.堆排序(向下调整,建小堆,排降序)
void Heapify(int array[], int size, int index)
{
	while ((2 * index + 1) < size)
	{
		int minindex = 2 * index + 1;
		int rightindex = 2 * index + 2;
		if (rightindex < size && array[rightindex] < array[minindex])
		{
			minindex = rightindex;
		}
		if (array[index] <= array[minindex])
			//如果根节点的值小于最小孩子的值,证明直接return.
		{
			break;
		}

		swap(array, index, minindex);
		//发生了交换,更新index
		index = minindex;
	}
}
//建堆
void CreatHeap(int array[], int size)
{
	for (int i = (size - 2) / 2; i >= 0; --i)
	{
		Heapify(array, size, i);
	}
}
//堆排序
void HeapSort(int array[], int size)
{
	CreatHeap(array, size);
	for (int i = size; i > 0; --i)
	{
		swap(array, 0, size - 1);
		size--;
		Heapify(array, size, 0);
	}
}

//3.插入排序  O(n^2)
void insertsort(int array[], int size)
{
	//一次处理一个数.size次,严格意义上size - 1 次就够了
	for (int i = 0; i < size; ++i)
	{
		//遍历整个有序区间   [0,i- 1],找位置
		int j = i;
		for (j = 0; j <= i - 1 && array[j] <= array[i]; ++j)
		{
			if (j != i)
			{
				//看做是把array[i]插入到[0,i- 1]的顺序表里,插入的下表是j
				int key = array[i];
				for (int k = i; k > j; --k)
				{
					array[k] = array[k - 1];
				}

				array[j] = key;
			}
		}
	}
}
void insertsort2(int array[], int size)
{
	for (int i = 0; i < size; ++i)
	{
		int key = array[i];
		int j;
		for (j = i - 1; j >= 0; j--)
		{
			array[j + 1] = array[i];
		}
		array[j + 1] = key;
	}
}

//4.冒泡排序   O(n^2)
void BubbleSort(int array[], int size)
{
	for (int bound = 0; bound < size; ++bound)
	{
		for (int i = size - 1; i >= bound; --i)
		{
			if (array[i] < array[i - 1])
			{
				int temp = array[i];
				array[i] = array[i - 1];
				array[i - 1] = temp;
			}
		}
	}
}

//5.选择排序
void SelectSort(int array[], int size)
{
	for (int i = 0; i < size; ++i)
	{
		for (int j = i + 1; j < size; ++j)
		{
			if (array[i] > array[j])
			{
				int temp = array[i];
				array[i] = array[j];
				array[j] = temp;
			}
		}
	}
}

void test()
{
	int array[10] = { 9, 5, 2, 7, 3, 8, 4, 6, 1, 0 };
	int size = sizeof(array) / sizeof(array[0]);
	for(int i = 0; i < size; ++i)
	{
		printf("%d ", array[i]);
	}
	printf("\n");
	HeapSort(array,size);
	for (int i = 0; i < size; ++i)
	{
		printf("%d ", array[i]);
	}
}
